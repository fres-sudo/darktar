import 'dart:io';

import 'package:path/path.dart' as p;

import 'package:darktar/jobs/job_queue.dart';
import 'package:darktar/storage/blob_storage.dart';

/// Job that generates documentation for a package version using dartdoc.
class DocGeneratorJob extends Job {
  DocGeneratorJob({
    required this.packageName,
    required this.version,
    required this.storage,
    required this.docsOutputPath,
    required this.themeDir,
  }) : super(
          id: '$packageName@$version',
          type: 'doc_generator',
        );

  final String packageName;
  final String version;
  final BlobStorage storage;
  final String docsOutputPath;
  final String themeDir;

  @override
  Future<void> execute() async {
    stdout.writeln('üìö Generating docs for $packageName@$version...');

    Directory? tempDir;

    try {
      // 1. Create temp directory
      tempDir = await Directory.systemTemp.createTemp('darktar_doc_');
      final packageDir = Directory(p.join(tempDir.path, packageName));
      await packageDir.create();

      // 2. Extract tarball
      final archivePath = 'packages/$packageName/$version.tar.gz';
      final archiveBytes = await storage.retrieve(archivePath);

      if (archiveBytes == null) {
        throw Exception('Archive not found: $archivePath');
      }

      await _extractTarball(archiveBytes, packageDir.path);

      // 3. Run dart pub get
      final pubGetResult = await Process.run(
        'dart',
        ['pub', 'get'],
        workingDirectory: packageDir.path,
      );

      if (pubGetResult.exitCode != 0) {
        stdout.writeln('‚ö†Ô∏è  pub get failed: ${pubGetResult.stderr}');
        // Continue anyway - docs might still generate
      }

      // 4. Prepare custom header/footer
      final headerFile = File(p.join(tempDir.path, 'header.html'));
      final footerFile = File(p.join(tempDir.path, 'footer.html'));

      await headerFile.writeAsString(_buildHeader(packageName, version));
      await footerFile.writeAsString(_buildFooter());

      // 5. Run dart doc
      final docResult = await Process.run(
        'dart',
        [
          'doc',
          '--output',
          'doc/api',
          '--header',
          headerFile.path,
          '--footer',
          footerFile.path,
        ],
        workingDirectory: packageDir.path,
      );

      if (docResult.exitCode != 0) {
        throw Exception('dart doc failed: ${docResult.stderr}');
      }

      // 6. Inject custom CSS
      final docOutputDir = Directory(p.join(packageDir.path, 'doc', 'api'));
      if (await docOutputDir.exists()) {
        await _injectCustomCss(docOutputDir.path);
      }

      // 7. Copy to final output location
      final finalOutputDir =
          Directory(p.join(docsOutputPath, packageName, version));
      await finalOutputDir.create(recursive: true);

      await _copyDirectory(docOutputDir, finalOutputDir);

      stdout.writeln('‚úÖ Docs generated for $packageName@$version');
    } catch (e, stack) {
      stderr.writeln('‚ùå Doc generation failed for $packageName@$version: $e');
      stderr.writeln(stack);
      rethrow;
    } finally {
      // Cleanup temp directory
      if (tempDir != null && await tempDir.exists()) {
        await tempDir.delete(recursive: true);
      }
    }
  }

  /// Extracts a tar.gz archive to a directory.
  Future<void> _extractTarball(List<int> bytes, String outputPath) async {
    final tarFile = File(p.join(outputPath, 'package.tar.gz'));
    await tarFile.writeAsBytes(bytes);

    final result = await Process.run(
      'tar',
      ['-xzf', tarFile.path, '-C', outputPath, '--strip-components=1'],
    );

    if (result.exitCode != 0) {
      throw Exception('Failed to extract tarball: ${result.stderr}');
    }

    await tarFile.delete();
  }

  /// Builds the custom header HTML.
  String _buildHeader(String packageName, String version) {
    return '''
<div class="darktar-header">
  <a href="/" class="darktar-logo">üì¶ Darktar</a>
  <span class="darktar-breadcrumb">
    <a href="/packages/$packageName">$packageName</a>
    <span>v$version</span>
  </span>
</div>
<style>
  .darktar-header {
    background: #1e293b;
    padding: 12px 24px;
    display: flex;
    align-items: center;
    gap: 24px;
    border-bottom: 1px solid #334155;
    position: sticky;
    top: 0;
    z-index: 1000;
  }
  .darktar-logo {
    font-weight: 700;
    font-size: 1.125rem;
    color: #f8fafc !important;
    text-decoration: none;
  }
  .darktar-breadcrumb {
    display: flex;
    gap: 8px;
    color: #94a3b8;
  }
  .darktar-breadcrumb a {
    color: #38bdf8 !important;
    text-decoration: none;
  }
</style>
''';
  }

  /// Builds the custom footer HTML.
  String _buildFooter() {
    return '''
<div class="darktar-footer">
  <p>Generated by <a href="/">Darktar</a> ‚Äî Private Dart Package Registry</p>
</div>
<style>
  .darktar-footer {
    background: #0f172a;
    padding: 24px;
    text-align: center;
    color: #64748b;
    border-top: 1px solid #334155;
  }
  .darktar-footer a {
    color: #38bdf8;
    text-decoration: none;
  }
</style>
''';
  }

  /// Injects custom CSS into dartdoc output.
  Future<void> _injectCustomCss(String docPath) async {
    final stylesDir = Directory(p.join(docPath, 'static-assets'));
    if (!await stylesDir.exists()) {
      return;
    }

    // Find and modify the main stylesheet
    final cssFile = File(p.join(stylesDir.path, 'styles.css'));
    if (await cssFile.exists()) {
      final content = await cssFile.readAsString();
      final customCss = _getCustomCss();
      await cssFile.writeAsString('$content\n\n/* Darktar Theme */\n$customCss');
    }
  }

  /// Returns custom CSS overrides for dark mode.
  String _getCustomCss() {
    return '''
/* Darktar Dark Theme Override */
:root {
  --color-bg: #0f172a;
  --color-fg: #f8fafc;
  --color-secondary: #94a3b8;
  --color-accent: #38bdf8;
  --color-border: #334155;
}

body {
  background-color: var(--color-bg) !important;
  color: var(--color-fg) !important;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif !important;
}

.sidebar {
  background-color: #1e293b !important;
  border-right: 1px solid var(--color-border) !important;
  width: 280px !important;
}

.sidebar a,
.sidebar li {
  color: var(--color-secondary) !important;
}

.sidebar a:hover {
  color: var(--color-accent) !important;
}

.main-content {
  background-color: var(--color-bg) !important;
}

h1, h2, h3, h4, h5, h6 {
  color: var(--color-fg) !important;
}

a {
  color: var(--color-accent) !important;
}

code, pre {
  background-color: #1e293b !important;
  color: #e2e8f0 !important;
  border-radius: 4px !important;
}

.breadcrumbs {
  color: var(--color-secondary) !important;
}

.footer {
  display: none !important;
}
''';
  }

  /// Copies a directory recursively.
  Future<void> _copyDirectory(Directory source, Directory destination) async {
    await for (final entity in source.list(recursive: false)) {
      final newPath = p.join(destination.path, p.basename(entity.path));

      if (entity is File) {
        await entity.copy(newPath);
      } else if (entity is Directory) {
        final newDir = Directory(newPath);
        await newDir.create();
        await _copyDirectory(entity, newDir);
      }
    }
  }
}
